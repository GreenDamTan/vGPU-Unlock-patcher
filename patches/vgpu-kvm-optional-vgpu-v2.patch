From: snowman <snowman@localhost.localdomain>
Subject: [PATCH] vgpu kvm optional vgpu v2

this is a second attempt to optionaly disable vgpu-kvm support
in nvidia driver via vgpukvm module parameter

allows to define secondary boot with vgpu-kvm disabled in order
to boot with nvidia driver switched to normal desktop mode without
replacing any driver files, just with use of nvidia.vgpukvm=0
in kernel boot parameters

this v2 fixes many compile warnings, also it is not anymore specific
only to merged driver as it can be useful with vgpu-kvm driver too,
for example to boot with efifb console that would normally get
destroyed by vgpu-kvm nvidia driver

also provided kmalimit nvidia module parameter to test override
of KMALLOC_LIMIT in os_alloc_mem()
---
 kernel/common/inc/nv-linux.h               |  2 ++
 kernel/nvidia-vgpu-vfio/nvidia-vgpu-vfio.c | 18 ++++++++++++++++++
 kernel/nvidia/nv-frontend.c                | 15 +++++++++++++++
 kernel/nvidia/nv-mmap.c                    |  2 +-
 kernel/nvidia/nv-pci.c                     | 10 ++++++++--
 kernel/nvidia/nv-vgpu-vfio-interface.c     |  3 +++
 kernel/nvidia/os-interface.c               | 12 ++++++++++--
 7 files changed, 57 insertions(+), 5 deletions(-)

diff --git a/kernel/common/inc/nv-linux.h b/kernel/common/inc/nv-linux.h
index 18dcf8d..17bb8d2 100644
--- a/kernel/common/inc/nv-linux.h
+++ b/kernel/common/inc/nv-linux.h
@@ -1830,6 +1830,8 @@ static inline NV_STATUS nv_check_gpu_state(nv_state_t *nv)
 
 extern NvU32 NVreg_EnableUserNUMAManagement;
 extern NvU32 NVreg_RegisterPCIDriver;
+extern int nv_vgpu_kvm_enable;
+extern unsigned nv_vgpukvm_kmalloc_limit;
 
 extern NvU32 num_probed_nv_devices;
 extern NvU32 num_nv_devices;
diff --git a/kernel/nvidia-vgpu-vfio/nvidia-vgpu-vfio.c b/kernel/nvidia-vgpu-vfio/nvidia-vgpu-vfio.c
index 6c88de7..5502c81 100644
--- a/kernel/nvidia-vgpu-vfio/nvidia-vgpu-vfio.c
+++ b/kernel/nvidia-vgpu-vfio/nvidia-vgpu-vfio.c
@@ -46,6 +46,8 @@ static void vgpu_msix_disable(vgpu_dev_t *vgpu_dev);
 static int do_vf_flr(struct mdev_device *mdev);
 
 
+static int *nv_vgpu_kvm_enable_ptr;
+
 NV_STATUS (*get_ops) (rm_vgpu_vfio_ops_t *);
 NV_STATUS (*set_ops) (vgpu_vfio_ops_t *);
 
@@ -4354,6 +4356,9 @@ static NV_STATUS nv_vgpu_probe(struct pci_dev *dev, NvU32 num_vgpu_types, NvU32
     char *vgpu_type_name = NULL;
     phys_dev_t *phys_dev = NULL;
 
+    if (nv_vgpu_kvm_enable_ptr != NULL && *nv_vgpu_kvm_enable_ptr == 0)
+        return status;
+
     down(&phys_devices.phys_dev_list_lock);
     if (((status = get_phys_dev(dev, &phys_dev)) != NV_OK) || (phys_dev != NULL))
     {
@@ -4474,6 +4479,9 @@ static void nv_vgpu_remove(struct pci_dev *dev)
 #if defined(NV_VGPU_KVM_BUILD)
     phys_dev_t *phys_dev, *tmp;
 
+    if (nv_vgpu_kvm_enable_ptr != NULL && *nv_vgpu_kvm_enable_ptr == 0)
+        return;
+
     if(list_empty(&phys_devices.phys_dev_list))
         return;
 
@@ -4516,6 +4524,10 @@ static void nv_vgpu_remove(struct pci_dev *dev)
 static int __init nv_vgpu_vfio_init(void)
 {
 #if defined(NV_VGPU_KVM_BUILD)
+    nv_vgpu_kvm_enable_ptr = symbol_get(nv_vgpu_kvm_enable);
+    if (nv_vgpu_kvm_enable_ptr != NULL && *nv_vgpu_kvm_enable_ptr == 0)
+        return 0;
+
     rm_vgpu_vfio_ops.version_string = NV_VERSION_STRING;
 
     get_ops = NULL;
@@ -4571,6 +4583,12 @@ static void __exit nv_vgpu_vfio_exit(void)
 #if defined(NV_VGPU_KVM_BUILD)
     phys_dev_t *phys_dev, *tmpdev;
 
+    if (nv_vgpu_kvm_enable_ptr != NULL) {
+        symbol_put(nv_vgpu_kvm_enable);
+            if (*nv_vgpu_kvm_enable_ptr == 0)
+                return;
+    }
+
     list_for_each_entry_safe(phys_dev, tmpdev, &phys_devices.phys_dev_list, next)
         mdev_unregister_device(&phys_dev->dev->dev);
 
diff --git a/kernel/nvidia/nv-frontend.c b/kernel/nvidia/nv-frontend.c
index 3ff220b..6a41ed3 100644
--- a/kernel/nvidia/nv-frontend.c
+++ b/kernel/nvidia/nv-frontend.c
@@ -365,6 +365,21 @@ static int __init nvidia_frontend_init_module(void)
     memset(nv_minor_num_table, 0, sizeof(nv_minor_num_table));
     NV_INIT_MUTEX(&nv_module_table_lock);
 
+#if defined(NV_VGPU_KVM_BUILD)
+#ifndef VUP_MERGED_DRIVER
+#define VUP_MERGED_DRIVER 0
+#endif
+    if (nv_vgpukvm_kmalloc_limit == 0) {
+        if (nv_vgpu_kvm_enable)
+            nv_vgpukvm_kmalloc_limit = 8192;
+        else
+            nv_vgpukvm_kmalloc_limit = 131072;
+    }
+    printk(KERN_INFO "nvidia: vgpu-kvm%s build vgpukvm=%d kmalimit=%u\n",
+        VUP_MERGED_DRIVER ? "-merged" : "",
+        nv_vgpu_kvm_enable, nv_vgpukvm_kmalloc_limit);
+#endif
+
     status = nvidia_init_module();
     if (status < 0)
     {
diff --git a/kernel/nvidia/nv-mmap.c b/kernel/nvidia/nv-mmap.c
index 85f6fae..07bd297 100644
--- a/kernel/nvidia/nv-mmap.c
+++ b/kernel/nvidia/nv-mmap.c
@@ -419,7 +419,7 @@ int static nvidia_mmap_sysmem(
 #endif
 
 #if defined(NV_VGPU_KVM_BUILD)
-        if (at->flags.guest)
+        if (nv_vgpu_kvm_enable && at->flags.guest)
         {
             ret = nv_remap_page_range(vma, start, at->page_table[j]->phys_addr,
                                       PAGE_SIZE, vma->vm_page_prot);
diff --git a/kernel/nvidia/nv-pci.c b/kernel/nvidia/nv-pci.c
index f3b4721..3340235 100644
--- a/kernel/nvidia/nv-pci.c
+++ b/kernel/nvidia/nv-pci.c
@@ -249,6 +249,7 @@ nv_pci_probe
     if (pci_dev->is_virtfn)
     {
 #if defined(NV_VGPU_KVM_BUILD)
+      if (nv_vgpu_kvm_enable) {
         nvl = pci_get_drvdata(pci_dev->physfn);
         if (!nvl)
         {
@@ -280,13 +281,15 @@ nv_pci_probe
 
         nv_kmem_cache_free_stack(sp);
         return 0;
-#else
+      } else
+#endif /* NV_VGPU_KVM_BUILD */
+      {
         nv_printf(NV_DBG_ERRORS, "NVRM: Ignoring probe for VF %04x:%02x:%02x.%x ",
                   NV_PCI_DOMAIN_NUMBER(pci_dev), NV_PCI_BUS_NUMBER(pci_dev),
                   NV_PCI_SLOT_NUMBER(pci_dev), PCI_FUNC(pci_dev->devfn));
 
         goto failed;
-#endif /* NV_VGPU_KVM_BUILD */
+      } /* NV_VGPU_KVM_BUILD */
     }
 #endif /* NV_PCI_SRIOV_SUPPORT */
 
@@ -584,6 +587,7 @@ next_bar:
     nv_parse_per_device_option_string(sp);
 
 #if defined(NV_VGPU_KVM_BUILD)
+    if (nv_vgpu_kvm_enable)
     if (nvidia_vgpu_vfio_probe(nvl->pci_dev) != NV_OK)
     {
         NV_DEV_PRINTF(NV_DBG_ERRORS, nv, "Failed to register device to vGPU VFIO module");
@@ -654,6 +658,7 @@ nv_pci_remove(struct pci_dev *pci_dev)
     {
 #if defined(NV_VGPU_KVM_BUILD)
         /* Arg 2 == NV_TRUE means that the PCI device should be removed */
+      if (nv_vgpu_kvm_enable)
         nvidia_vgpu_vfio_remove(pci_dev, NV_TRUE);
 #endif /* NV_VGPU_KVM_BUILD */
         return;
@@ -743,6 +748,7 @@ nv_pci_remove(struct pci_dev *pci_dev)
 
 #if defined(NV_VGPU_KVM_BUILD)
     /* Arg 2 == NV_TRUE means that the PCI device should be removed */
+    if (nv_vgpu_kvm_enable)
     nvidia_vgpu_vfio_remove(pci_dev, NV_TRUE);
 #endif
 
diff --git a/kernel/nvidia/nv-vgpu-vfio-interface.c b/kernel/nvidia/nv-vgpu-vfio-interface.c
index 375c72b..6d2c539 100644
--- a/kernel/nvidia/nv-vgpu-vfio-interface.c
+++ b/kernel/nvidia/nv-vgpu-vfio-interface.c
@@ -513,6 +513,9 @@ NV_STATUS NV_API_CALL os_call_vgpu_vfio(void *pvgpu_vfio_info, NvU32 cmd)
     nv_linux_state_t  *nvl;
     struct pci_dev    *pci_dev = NULL;
 
+    if (!nv_vgpu_kvm_enable)
+        return NV_ERR_NOT_SUPPORTED;
+
     switch (cmd)
     {
         case CMD_VGPU_VFIO_WAKE_WAIT_QUEUE:
diff --git a/kernel/nvidia/os-interface.c b/kernel/nvidia/os-interface.c
index 3dc2bfe..15b1a62 100644
--- a/kernel/nvidia/os-interface.c
+++ b/kernel/nvidia/os-interface.c
@@ -466,7 +466,15 @@ NvS32 NV_API_CALL os_mem_cmp(
  * particularly if hugetlbfs hugepages are being used. Hence, 8K applies
  * here too.
  */
-#define KMALLOC_LIMIT 8192
+
+unsigned nv_vgpukvm_kmalloc_limit; // default for vgpu-kvm: 8192
+module_param_named(kmalimit, nv_vgpukvm_kmalloc_limit, uint, 0600);
+
+int nv_vgpu_kvm_enable = 1;
+module_param_named(vgpukvm, nv_vgpu_kvm_enable, int, 0400);
+EXPORT_SYMBOL(nv_vgpu_kvm_enable);
+
+#define KMALLOC_LIMIT nv_vgpukvm_kmalloc_limit
 #else
 #define KMALLOC_LIMIT 131072
 #endif
@@ -1291,7 +1299,7 @@ NvBool NV_API_CALL os_is_xen_dom0(void)
 NvBool NV_API_CALL os_is_vgx_hyper(void)
 {
 #if defined(NV_VGX_HYPER)
-    return NV_TRUE;
+    return nv_vgpu_kvm_enable ? NV_TRUE : NV_FALSE;
 #else
     return NV_FALSE;
 #endif
-- 
2.30.2

